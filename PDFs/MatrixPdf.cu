/*****************************************************************************
 * Project: GooFit                                                           *
 *                                                                           *
 * This code was autogenerated by                             *
 *                                                                           *
 * A simple AA PDF class by Ivan Heredia de la Cruz on 4/25/16.              *
 *****************************************************************************/


#include <math.h>
#include "TMath.h"

#include "MatrixPdf.hh"


EXEC_TARGET devcomplex<fptype> WignerD_J(int helJ,int helDmu, fptype angle) const
{

  devcomplex<fptype> imJ(0.,1.);

  if (helJ==M1) {
    if (helDmu==M1)
      return +((+1. + cJ)*exp(imJ*angle))/2.;
    else if (helDmu==P1)
      return -((-1. + cJ)*exp(imJ*angle))/2.;
    else {
      cout <<"helDmu = " <<helDmu <<" not allowed in \"WignerD_J\" functions for helJ = " <<helJ <<" at the moment. Returning 0 -> \"AngularTerm\" = 0" <<endl ;
      return 0; }
  } else if (helJ==ZERO) {
    if (helDmu==M1)
      return -(pow(1. - pow(cJ,2))/TMath::Sqrt2());
    else if (helDmu==P1)
      return +(pow(1. - pow(cJ,2))/TMath::Sqrt2());
    else {
      cout <<"helDmu = " <<helDmu <<" not allowed in \"WignerD_J\" functions for helJ = " <<helJ <<" at the moment. Returning 0 -> \"AngularTerm\" = 0" <<endl ;
      return 0; }
  } else if(helJ==P1) {
    if (helDmu==M1)
      return -(-1. + cJ)/(2.*exp(imJ*angle));
    else if (helDmu==P1)
      return +(+1. + cJ)/(2.*exp(imJ*angle));
    else {
      cout <<"helDmu = " <<helDmu <<" not allowed in \"WignerD_J\" functions for helJ = " <<helJ <<" at the moment. Returning 0 -> \"AngularTerm\" = 0" <<endl ;
      return 0; }
  } else {
    cout <<"helJ = " <<helJ <<" not allowed in \"WignerD_J\" functions at the moment. Returning 0 -> \"AngularTerm\" = 0" <<endl ;
    return 0;
  }

}

// H term in slide 11 second last line for Lambda*(1600)
EXEC_TARGET fptype HLs1600(std::string help) const
{

    if(help==M1H)
        return -1.;
    else if(help==P1H)
        return 1.;
    else { cout <<"WARNING! In \"HLs1600\" function: help = " <<help <<" -> returning 0" <<endl;
        return 0.;
    }
}

// H term in slide 11 second last line for Lambda*(1670)
EXEC_TARGET fptype HLs1670(std::string help) const
{

    if(help==M1H)
        return 1.;
    else if(help==P1H)
        return 1.;
    else { cout <<"WARNING! In \"HLs1670\" function: help = " <<help <<" -> returning 0" <<endl;
        return 0.;
    }

}

EXEC_TARGET devcomplex<fptype> ME( std::string helDmu ) const
{
  /*
  // K+ and pi- have 0 spin -> second last argument of K* RFunction is = spin(K*)
  return
    RFunction(M892, G892, MBd, 0, 1, dRad) * ( AngularTerm("K*(892)", "1", M1, helDmu) +
						      AngularTerm("K*(892)", "1", ZERO, helDmu) +
						      AngularTerm("K*(892)", "1", "p1", helDmu) )
    // + ...
    ;
  // any other K* should be added above
  */
  devcomplex<fptype> matrixElement(0.,0.);
  // K+ and pi- have 0 spin -> second last argument of K* RFunction is = spin(K*)
  for (Int_t iKstar_S=0; iKstar_S<(Int_t)Kstar_spin.size(); ++iKstar_S) {
    TString R = Kstar_spin[iKstar_S].first ;
    TString spin = R(Kstar_spin[iKstar_S].first.Length() -1) ;
    TString mass = R(0, Kstar_spin[iKstar_S].first.Length() -2) ;
    devcomplex<fptype> matrixElement_R = 0.;
    if (spin.EqualTo(ZERO)) { // for spin0 K*, third last argument = spin(psi_nS) = spin.Atoi() + 1 = 1
      matrixElement_R = RFunction(Kstar_spin[iKstar_S].second.first, Kstar_spin[iKstar_S].second.second, MBd, spin.Atoi()+1, spin.Atoi(), dRadB0, dRadKs) *
	               AngularTerm(R, spin, ZERO, helDmu) ;
    } else { // for non-0 spin K*, third last argument = spin(K*) - spin(psi_nS) = spin.Atoi() - 1
      matrixElement_R = RFunction(Kstar_spin[iKstar_S].second.first, Kstar_spin[iKstar_S].second.second, MBd, spin.Atoi()-1, spin.Atoi(), dRadB0, dRadKs) *
	               ( AngularTerm(R, spin, M1, helDmu) + AngularTerm(R, spin, ZERO, helDmu) + AngularTerm(R, spin, "p1", helDmu) ) ;
    }
    //cout <<"\nAngularTerm.Rho() for " <<R <<" = " <<(AngularTerm(R, spin, ZERO, helDmu)).Rho() <<endl;
    //cout <<"matrixElement for (R,helDmu) = (" <<R <<"," <<helDmu <<") = H(R,helJ) * RFunction * AngularTerm = " <<matrixElement_R <<endl;
    matrixElement += matrixElement_R;
    //cout <<"matrixElement_R.Rho2() for (R,helDmu) = (" <<R <<"," <<helDmu <<") = " <<matrixElement_R.Rho2() <<"\n\n" <<endl;
  }
  return matrixElement ;

}

EXEC_TARGET fptype ME2() const
{
  //cout <<"\nME(\"m1\") + ME(\"p1\") = " <<ME(M1) <<" + " <<ME("p1") <<endl;
  //cout <<"ME(\"m1\").Rho2() + ME(\"p1\").Rho2() = " <<ME(M1).Rho2() <<" + " <<ME("p1").Rho2() <<endl;
  return ME(M1).Rho2() + ME(P1).Rho2() ;
}

//TComplex myPDF::PDF() const
EXEC_TARGET fptype PDF() const
{
  //cout <<"\nME2() = " <<ME2() <<endl;
  return ME2() * PhiPHSP(mKP); // missing * efficiency(from reconstructed PHSP MC)

}
